# Инструкция: Связь двух серверов (RU -> EU) и настройка PHP

Эта инструкция поможет настроить безопасный туннель между вашим **Российским сервером (RU)** и **Европейским сервером (EU)** для передачи больших данных (JSON, файлы) в обход DPI.

## Схема работы

1.  **RU Сервер (Клиент)**: PHP скрипт отдает данные локальному `dropdpi-client`. Клиент шифрует их, дробит и отправляет в Европу.
2.  **EU Сервер (Сервер)**: Принимает куски, собирает их и передает вашему скрипту-обработчику (или в интернет).

---

## Шаг 1: Настройка Европейского Сервера (EU)

Этот сервер будет принимать соединения.

1.  **Установите Go и скачайте проект** (см. README.md).
2.  **Соберите сервер**:
    ```bash
    go build -o dropdpi-server cmd/server/main.go
    ```
3.  **Настройте Config**:
    Сервер готов к работе "из коробки" с настройками по умолчанию.
    Если хотите поменять порт или ключ, используйте переменные окружения:

    ```bash
    export DROPDPI_SERVER_LISTEN=":9999"
    ```

4.  **Запустите сервер**:
    ```bash
    ./dropdpi-server
    ```
    _Порт `8443` (или ваш) должен быть открыт._

Теперь ваш EU сервер ждет зашифрованные данные.

---

## Шаг 2: Настройка Российского Сервера (RU)

Этот сервер будет отправлять данные.

1.  **Установите Go и скачайте проект**.
2.  **Настройте Клиент**:
    Самый простой способ — задать переменную окружения перед запуском:

    ```bash
    export DROPDPI_SERVER_ADDRESS="IP.АДРЕС.EU.СЕРВЕРА:8443"
    ```

    _Остальные настройки (ключ, порт) возьмутся по умолчанию, если вы их не меняли._

3.  **Соберите клиент**:
    ```bash
    go build -o dropdpi-client cmd/client/main.go
    ```
4.  **Запустите клиент**:
    ```bash
    ./dropdpi-client
    ```
    _Теперь на `127.0.0.1:1080` работает ваш личный секретный туннель._

---

## Шаг 3: Настройка PHP (Guzzle) на RU Сервере

Теперь нужно научить ваш PHP код отправлять запросы через этот туннель.

Если вы используете **GuzzleHttp**, добавьте параметр `proxy`.

```php
<?php

require 'vendor/autoload.php';

use GuzzleHttp\Client;

$client = new Client([
    // Базовый адрес (куда шлем запрос).
    // Если скрипт-приемник лежит на том же EU сервере, можно обращаться по IP или домену.
    'base_uri' => 'http://IP.АДРЕС.EU.СЕРВЕРА',

    // ВАЖНО: Направляем трафик через наш DropDPI (SOCKS5)
    'proxy' => 'socks5h://127.0.0.1:1080',

    'timeout'  => 30.0,
]);

// Большой массив данных
$bigData = [
    'status' => 'ok',
    'payload' => str_repeat('A', 1024 * 1024 * 5), // 5 MB данных
    // ... ваши данные ...
];

try {
    $response = $client->request('POST', '/api/receive.php', [
        'json' => $bigData
    ]);

    echo "Ответ сервера: " . $response->getBody();
} catch (\Exception $e) {
    echo "Ошибка: " . $e->getMessage();
}
```

**Что происходит?**

1.  Guzzle формирует огромный JSON.
2.  Отправляет его в `127.0.0.1:1080`.
3.  DropDPI нарезает его на кусочки по 1 КБ, шифрует AES-256.
4.  Отправляет кусочки в Европу по 3 разным каналам.
5.  Российский DPI видит только "белый шум" и мелкие пакеты -> **Не блокирует**.
6.  DropDPI на EU сервере собирает JSON и отдает его вашему скрипту `/api/receive.php`.

---

## Решение проблемы с картинками

Вы писали: _"если европейский видит картинки он пытается их скачать"_.

Если EU сервер пытается скачать картинки **из интернета** (например, с Instagram, Google), то проблем не будет — в Европе интернет свободный.

Если же EU сервер пытается скачать картинки **обратно с Российского сервера** (по ссылкам в JSON), то DPI может заблокировать этот входящий запрос в Россию.

**Решение:**
Не заставляйте EU сервер качать картинки. Передайте их **внутри** JSON.

Так как мы теперь умеем передавать огромные JSON без блокировок, закодируйте картинки в Base64 прямо на стороне PHP (RU):

```php
// На RU сервере (Отправка)
$imageData = base64_encode(file_get_contents('image.jpg'));

$payload = [
    'title' => 'My Post',
    'image_base64' => $imageData // Картинка летит внутри шифрованного туннеля
];

$client->post('/receive.php', ['json' => $payload]);
```

```php
// На EU сервере (Прием)
$data = json_decode(file_get_contents('php://input'), true);
if (isset($data['image_base64'])) {
    file_put_contents('downloaded_image.jpg', base64_decode($data['image_base64']));
}
```

Так вы полностью избежите лишних соединений и блокировок.
